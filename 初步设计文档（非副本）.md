## 系统架构

整体架构采用分布式的方式，包括Coordinator、Worker和Aggregator三个主要组件。

1. **Coordinator（协调节点）：** 负责任务的分配和调度，管理整个系统的状态信息。
2. **Worker（工作节点）：** 负责更新Git仓库、处理数据。可部署在各个家庭服务器上，无需公网IP。
3. **Aggregator（聚合节点）：** 负责汇总各个Worker数据，从worker上拉取更新，并提供统一的服务接口给外部用户。Aggregator拥有公网IP，可供外部访问。



## 组件功能

1. **Coordinator：**
   - 轻量级节点，拥有公网IP
   - 读取配置文件，管理数据。
   - 负责任务的分配和调度，将Git仓库URL分配给不同的Worker。
   - 与Aggregator交互。
2. **Worker：**
   - 从Git托管服务商（如GitHub、GitLab、Gitee）更新Git仓库数据，并实现增量同步。
   - 提供服务接口，响应Aggregator和Coordinator的请求。
   - 将本地状态和数据汇报给Coordinator。
3. **Aggregator：**
   - 从各个Worker收集数据，并进行汇总。
   - 拥有公网IP，提供统一的服务接口给外部用户，例如提交任务、获取数据等。



> **【worker/aggregator是否可合并? 成为一个模块里的两种运行模式：partial/full模式】**
>
> 可行。
>
> **Partial模式：** 在Partial模式下充当Worker的角色，负责从上游Git托管服务拉取指定的Git仓库数据并进行增量同步。它会定期轮询上游仓库，根据更新活跃度自适应地执行Git Pull操作频率。此模式下的核心功能是实现Git仓库的增量同步。
>
> **Full模式：** 在Full模式下充当Aggregator的角色，负责整体协调和服务提供。它会接收来自Partial模式的数据，并将所有拉取的仓库数据集中在一起。在Full模式中，还包含处理API请求、动态添加/更新Git URL等功能。此模式下的核心功能是对外提供API接口，允许用户按需触发Git仓库的拉取操作，并管理Git仓库的配置信息。



## 通信方式

1. **Coordinator与Worker之间：** Worker向Coordinator注册自己的状态，接收分配的任务，并定期汇报任务执行状态和结果（可使用轻量级RPC或消息队列来实现通信）
2. **Aggregator与Worker之间：** Aggregator向Worker请求最新数据（同样可使用RPC或消息队列来实现通信）
3. **Coordinator与Aggregator之间：** Coordinator将从Worker收集到的数据请求发送给Aggregator，Aggregator进行数据汇总和处理后，将结果返回给Coordinator。（可使用HTTP或其他协议来实现）
4. **外部用户与Aggregator之间的通信：** 用户可通过HTTP API与Aggregator交互，提交任务、获取数据等操作。



## 数据存储

用数据库存储各Git仓库的信息和状态数据，包括：

​	仓库URL、最新更新时间、拉取状态....

​	（可选择关系型数据库或NoSQL数据库）



# 数据结构

- 配置文件格式
- 磁盘repos dir layout
- 数据库表
- API/消息格式
- 内部数据结构

....



## 仓库下发worker机制

Coordinator中存有仓库URL list，采用一致性哈希算法来分配对应的worker。

由于在分布式集群中worker节点的个数会不定时调整（增加n个worker或n个worker挂机的情况），如果采用常规哈希，在面对节点数量变化时选择重新去仓库列表源Coordinator中大规模进行仓库的重新分配，效率会很低且耗时间。

考虑节点数量变化的场景，可以采用一致性哈希算法去解决。



将repo哈希值映射到0-n空间中，且将这个范围首尾相连形成一个环。再解决worker负载不均的问题（当worker数量少时，有种情况是如果当前workerA挂了，那么原本workerA维护的n个仓库将全部由顺时针的下个workerB进行维护，导致负载不均），在一致性哈希的基础上引入虚拟worker的概念，一个真实worker对应n个虚拟worker。代价非常小，只需增加一个map维护真实节点与虚拟节点的映射关系即可。

映射过程如下：

Coordinator给出一个URL-> hash-> 对应到对应的worker

hash过程如下：

- 计算虚拟worker(使用worker的IP地址)的哈希值，放在环上。
- 计算仓库（使用仓库URL）的哈希值，对哈希值进行判断-> 顺时针寻找到的第一个节点，就是应选取对应的worker。

*（可参考图“一致性哈希.png”，其中key即为repo，peer即为worker）*

![](https://github.com/yanyanran/pictures/blob/main/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C.png?raw=true)



##  POLL interval 自适应算法

- adaptive
- rate limit
- retry
- on demand

...



## 故障检测和自动恢复机制

...



## **功能列表：**

**Story 1: Pull Upstream Repo**

- 功能：从上游GitHub拉取指定Git仓库数据进行增量同步。
- 包含的操作：
  - 从上游Git托管服务下载指定Git仓库的代码和历史记录。
  - 实现增量同步，只拉取新的提交，避免重复下载已有的数据。
  - 定期轮询上游仓库，根据更新活跃度自适应间隔进行Git Pull操作。
- 输入：无（自动定时任务或系统内部触发）
- 输出：Git仓库最新的提交数据或增量更新的提交数据。

**Story 2: GitHub Webhook**

- 功能：通过GitHub的Webhook机制实现Git仓库的自动同步。
- 包含的操作：
  - 注册GitHub Webhook，将仓库的更新事件推送到系统中。
  - 根据接收到的Webhook消息，识别出哪个Git仓库有更新。
  - 触发相应的Worker执行Git Pull操作，拉取更新的数据。
- 输入：GitHub Webhook消息（包含更新的Git仓库URL等信息）
- 输出：无（触发Git Pull操作）

**Story 3: On Demand (API)**

- 功能：提供API接口，允许外部用户按需触发Git仓库的拉取操作。
- 包含的操作：
  - 设计API接口，接收外部用户提交的Git仓库URL和拉取请求。
  - 根据API请求，将拉取任务分配给合适的Worker进行处理。
  - Worker执行Git Pull操作，获取最新的仓库数据，并将结果返回给用户。
- 输入：外部用户提交的拉取任务请求（包含Git仓库URL和其他相关信息）

- 输出：任务状态和结果数据。

**Story 4: Dynamic Add/Update Git URLs (API)**

- 功能：提供API接口，允许动态添加或更新需要拉取的Git仓库URL。
- 包含的操作：
  - 设计API接口，接收外部用户提交的Git仓库URL和相关信息。
  - 将新的Git仓库URL添加到系统中，或者更新已有的Git仓库URL的相关信息。
  - 根据情况将新增或更新的Git仓库URL分配给合适的Worker进行处理。
- 输入：外部用户提交的Git仓库URL和相关信息
- 输出：Git仓库的添加/更新状态信息。 



## API设计

1. **提交任务API（On Demand）：**

   - 接口：POST /api/tasks

   - 输入：

     ```
     {
       "git_url": "https://github.com/username/repo.git",
       "additional_params": { /* 可选的其他参数 */ }
     }
     ```

   - 输出：

     ```
     {
       "task_id": "123456",
       "status": "pending"
     }
     ```

2. **获取任务状态API：**

   - 接口：GET /api/tasks/{task_id}

   - 输出：

     ```
     {
       "task_id": "123456",
       "status": "running",
       "progress": "50%",
       "result": null /* 或者包含任务结果的数据 */
     }
     ```

3. **动态添加/更新Git URL API：**

   - 接口：POST /api/git_urls

   - 输入：

     ```
     {
       "git_url": "https://github.com/username/repo.git",
       "additional_info": { /* 可选的其他信息 */ }
     }
     ```

   - 输出：

     ```
     {
       "git_url": "https://github.com/username/repo.git",
       "status": "added"
     }
     ```

**数据结构：**

1. 任务数据结构：

   ```
   {
     "task_id": "123456",
     "status": "running", /* 任务状态：running, pending, success, failure 等 */
     "progress": "50%", /* 可选的任务进度信息 */
     "result": { /* 可选的任务执行结果数据 */ },
     "created_at": "2023-07-27T12:00:00Z",
     "updated_at": "2023-07-27T12:30:00Z"
   }
   ```

2. Git仓库数据结构：

   ```
   {
     "git_url": "https://github.com/username/repo.git",
     "additional_info": { /* 可选的其他信息 */ },
     "last_updated": "2023-07-27T12:00:00Z",
     "status": "active" /* 仓库状态：active, inactive 等 */
   }
   ```

